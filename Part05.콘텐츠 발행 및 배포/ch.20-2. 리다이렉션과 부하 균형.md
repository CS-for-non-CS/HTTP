# 5. 프락시 리다이렉션 방법

웹브라우저와 같은 클라이언트가 어떻게 프락시로 가는 길을 알까? 세 가지 방법이 있다.

## 5-1. 명시적 브라우저 설정

대부분의 브라우저에는 프락시 서버에 접촉하기 위해 `프락시 이름`, `IP 주소`, `포트번호`를 설정할 수 있는 `풀다운 메뉴`가 존재한다.

사용자가 이를 설정할 경우, 브라우저는 모든 요청에 대해 프락시와 접촉한다.

몇몇 서비스 제공자들은 사용자들이 미리 프락시 설정이 되어 있는 브라우저를 다운 받도록 한다. 이 브라우저들은 접촉할 프락시의 주소를 알고 있다.

이 방식에는 두 가지 단점이 존재하는데,

- 프락시의 응답이 없는 경우에도 원 서버와 접촉을 시도하지 않는다. 프락시의 에러, 브라우저의 잘못된 설정 등은 사용자의 접속 문제로 이어질 수 있다.
- `네트워크 아키텍쳐`를 변경했을 때 변경사항을 모든 `최종사용자`에게 전파하기 쉽지 않다. 브라우저 사용자들이 수동으로 프락시 설정을 바꿔줘야 한다.



## 5-2. 프락시 자동 설정

이 방법은 브라우저 스스로 동적으로 프락시 설정을 변경하는 방법이다. `프락시 자동설정(Proxy Auto-configuration, PAC)` 프로토콜이라고 부르며, 거의 모든 브라우저가 지원한다.

브라우저는 URL별로 접촉해야 할 프락시의 정보가 담겨 있는 `PAC파일`을 찾는다. 이 파일을 얻기 위해 지정된 서버가 존재하며, 브라우저는 재시작할 때마다 이 파일을 가져온다.

##### PAC 파일

PAC파일은 다음의 함수가 필수적으로 포함되어 있는 자바스크립트 파일이다.

```javascript
function FindProxyForURL(url, host)
```

브라우저는 요청된 URL마다 다음과 같이 이 함수를 호출한다.

```javascript
return_value = FindProxyForURL(url_of_request, host_in_url);
```

이 함수는 `접촉할 프락시들의 목록` 혹은 원 서버와 바로 접촉하라는 뜻인 `DIRECT` 문자열을 반환한다.

##### PAC 프로토콜

PAC 프로토콜은 상당히 유용하다. DNS 주소, 서브넷, 시간, 호스트 명 등 여러 변수에 따라 프락시를 선택하도록 요구할 수 있다.

네트워크 아키텍쳐를 변경하더라도 PAC파일만 업데이트해주면 되기 때문에 브라우저는 자동으로 올바른 프락시에 접촉할 수 있다.



## 5-3. 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

이 방법은 브라우저가 `근처의 프락시`를 찾아내어 사용할 수 있게 해준다.

### PAC 파일 자동발견

WPAD 프로토콜을 구현한 HTTP 클라이언트는 다음과 같은 일을 한다.

1. WPAD를 이용해 PAC 파일 CURL을 찾는다.
2. URL에 해당하는 PAC 파일(설정파일 혹은 CFILE이라고도 알려진)을 가져온다.
3. 프락시 서버를 알아내기 위해 PAC 파일을 실행한다.
4. PAC 파일이 반환한 프락시 서버에게 HTTP 요청을 보낸다.

PAC 파일이 제공하는 유용한 기능들(부하 균형, 서버들의 배열로 요청 라우팅, 프락시 서버를 보조하기 위한 자동화된 장애 시의 대체 작동 등)을 활용하기 위해 WPAD는 클라이언트에게 PAC 파일만 전달할 뿐 직접적으로 프락시 서버의 이름을 알아내지는 않는다.

> CURL?
>
> 다양한 프로토콜을 지원하는 `데이터 전송용 Command Line Tool`이다. 아래와 같은 형태로 사용한다.
>
> ```
> curl http://httpbin.org/ip
> ```



### WPAD 알고리즘

WPAD는 적절한 PAC 파일 CURL을 결정하기 위해 여러 발견 기법들을 시도한다. 오늘날 WPAD 명세는 다음의 기법을 순서대로 정의하고 있으며, WPAD 클라이언트는 CURL을 얻는 데에 성공할 때까지 각각의 기법을 차례대로 시도한다.

- DHCP(Dynamic Host Configuration Protocol, 동적 호스트 설정 프로토콜)
- SLP(Service Location Protocol, 서비스 위치 프로토콜)
- DNS에게 잘 알려진 호스트 명
- DNS의 SRV 레코드
- TXT 레코드의 DNS 서비스 URL들

이 중 WPAD 클라이언트가 필수적으로 가지고 있어야 하는 메커니즘은 `DHCP`와 `DNS에게 잘 알려진 호스트 명`이다.

WPAD 클라이언트는 그들이 지원하는 메커니즘을 차례대로 시도한다. 성공할 경우, 과정은 완료되고 실패할 경우엔 프락시 서버를 사용하지 않는 것으로 설정된다.

DHCP와 SLP를 시도한 이후의 메커니즘들을 시도할 때는 처음엔 가장 구체적인 정보를 찾는 것을 시도하다가, 요청에 실패하면 점점 덜 구체적인 정보를 찾는 것을 시도한다.

```
QNAME=wpad.development.foo.com
QNAME=wpad.foo.com // 덜 구체적이다
```



### DHCP를 이용한 CURL 발견

이 메커니즘이 동작하기 위해서 DHCP 서버는 반드시 CURL을 저장하고 있어야 한다. CURL은 DHCP `옵션 252`에 들어있다.

WPAD 클라이언트가 자신의 초기화 과정에서 이미 DHCP 질의를 했다면, DHCP 서버가 이미 제공한 값을 OS의 API를 통해 얻을 수 있다. 없다면, `DHCPINFORM 메시지`를 DHCP 서버에게 보내 그 값을 얻는다.

WPAD를 위한 DHCP 옵션 코드 252는 임의의 길이의 문자열이다. 이 문자열은 적절한 PAC 파일을 가리키는 URL을 포함한다.



### DNS A 레코드 룩업

WPAD 클라리언트는 A 레코드 룩업을 DNS 서버로 보내 CURL을 얻는다. 룩업이 성공하면 적절한 프락시 서버의 IP 주소를 얻는다. 클라이언트는 아래와 같은 형식으로 요청한다.

```
QNAME=wpad, TGTDOM, QCLASS=IN, QTYPE=A
```



### PAC 파일 가져오기

후보 CURL을 얻은 뒤 클라이언트는 그 CURL로 GET 요청을 만든다. 이 때, 자신이 다룰 수 있는 CFILE 포맷 정보가 담긴 `Accept 헤더`가 포함되어야 하는데 다음과 같다.

```
Accept: application/x-ns-proxy-autoconfig
```

만약 CURL 결과가 `리다이렉트`라면, 그 리다이렉트가 향하는 곳이 클라이언트의 최종 목적지이다.



### 언제 WPAD를 실행하는가

WPAD는 적어도 다음 중 하나의 상황에서는 수행되어야 한다.

- 웹 클라이언트가 시작될 때(WPAC는 오직 `첫 인스턴스의 시작` 때만 수행된다. 이후의 인스턴스는 설정을 물려받는다.)
- 클라이언트의 호스트의 IP 주소가 변경된 네트워킹 스택으로부터 어떤 언급이 있을 때마다
- PAC 파일이 만료되었을 때
- PAC 파일이 대체품을 제공하지 않고, 현재 설정된 프락시가 동작하지 않을 때



### WPAD 스푸핑(spoofing)

WPAD 알고리즘은 호스트 명 `wpad`를 도메인 이름의 절대 표기 앞에 붙이고 CURL을 찾을 때까지 서브도메인을 지운다. 이는 보안 취약점을 노출할 수 있는데, 3차 도메인은 신뢰하기 어렵기 때문이다.



### 타임아웃

WPAD는 각 발견 단계에 걸리는 시간을 지켜보고 제한해야 한다.



### 관리자를 위한 고려사항

클라이언트들이 반드시 구현해야 하는 것은 `DHCP`와 `DNS A 레코드 검색` 뿐이다. 따라서 관리자들 역시 이 둘 중 하나를 설정해야 한다.

WPAD가 `근접성`을 결정할 때 다음과 같은 가능성들을 고려할 수 있다.

- DHCP 서버들은 서브넷에 따라 다른 답을 돌려줄 수 있다. 그 답들은 또한 클라이언트의 `cipaddr` 필드나 식별자 옵션에 대한 결정에도 근거한다.
- DNS 서버는 도메인 접미사에 따라 다른 SRV/A/TXT 리소스 레코드(RRs)를 반환하도록 설정될 수 있다.
- CURL 요청을 다루는 웹 서버는 User-Agent 헤더, Accept 헤더, 클라이언트 IP 주소/서브넷/호스트 명, 인근 프락시 서버들의 위상기하학적 배치 등에 근거하여 결정을 내릴 수 있다. 이는 CURL을 다루기 위해 생성된 CGI 실행프로그램 안에서도 일어날 수 있다. 이러한 결정을 내리는 것은 심지어 프락시 서버일 수도 있다.
- PAC 파일은, 여러 대안 중 하나를 클라이언트에서 실시간으로 선택할 수 있을 만한 충분한 표현력을 갖고 있을 수도 있다. CARP는 이 전제를 바탕으로 캐시의 배열을 지원한다.





# 6. 캐시 리다이렉션 방법

캐싱 프락시 서버를 위해 사용되는 리다이렉션 방법은 신뢰성 높고, 고성능에, 콘텐츠 지각 디스패칭까지 가능하게 하려고 하기 때문에, 다른 프로토콜보다 더 복잡하다.

## 6-1. WCCP 리다이렉션

라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고(실행되어 있고 동작 중임을), 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해준다.

### WCCP 리다이렉션 동작

- 네트워크 필요. 라우터와 캐시가 포함되어야 한다.
- 라우터와 캐시의 집합이 WCCP 서비스 그룹을 구성한다. 서비스 그룹의 설정은 트래픽 방향, 부하 분산 등에 대해 명시한다.
- 만약 서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있다면, 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보낸다.
- HTTP 요청이 서비스 그룹의 라우터에 도착했을 때, 라우터는 그 요청을 처리하기 위해 서비스 그룹의 캐시 중 하나를 선택한다. 이 때 선택은 요청 IP 주소의 해시값, 마스크/값 집합 짝짓기(pairing) 스킴 중 하나에 근거한다.
- 라우터는 요청 패킷을 캐시의 IP 주소와 함께 `캡슐화`하거나 IP 맥 포워딩을 하여 캐시로 보낸다.
- 만약 캐시가 요청을 처리할 수 없다면, 패킷은 평범하게 포워딩되기 위해 라우터로 돌아온다.
- 서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해 `하트비트 메시지`를 교환한다.

### WCCP2 메시지들

| 메시지 이름           | 누가 보내는가                                                | 전달하는 정보                                                |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| WCCP2_HERE_I_AM       | 캐시가 라우터에게                                            | 캐시가 라우터에게 트래픽을 받을 수 있다고 말해주는 메시지다. 캐시의 서비스 그룹 정보 전체를 담고 있다. 어떤 캐시가 서비스 그룹에 가입하면 그 캐시는 바로 그룹의 모든 라우터에게 이 메시지를 보낸다. |
| WCCP2_I_SEE_YOU       | 라우터가 캐시에게                                            | WCCP2_HERE_I_AM 메시지에 응답하는 메시지다. 패킷 포워딩 방법, 할당 방법, 패킷 반환 방법 그리고 보안에 대해 협상하기 위해 사용한다. |
| WCCP2_REDIRECT_ASSIGN | 지정된 캐시가 라우터에게                                     | 부하 균형을 위한 할당을 한다. 해시 테이블 부하 균형을 위한 버킷 정보나 마스크/값 집합 짝 정보를 보낸다. |
| WCCP2_REMOVAL_QUERY   | 라우터가 2.5 * HERE_I_AM_T 초 동안 WCCP2_HERE_I_AM 메시지를 보내지 않은 캐시에게 | 캐시가 서비스 그룹에서 제거되어야 하는지 알아보기 위해 이 메시지를 보낸다. 이에 대한 캐시의 올바른 응답은 HERE_I_AM_T/10 초 간격으로 세 번 동일한 WCCP2_HERE_I_AM 메시지를 보내는 것이다. |

### 메시지 구성 요소

각 메시지는 `헤더`와 `구성요소`로 구성되어 있다. WCCP 헤더 정보는 메시지의 종류, WCCP 버전, 메시지의 길이(헤더의 길이는 포함되지 않은)를 포함한다.

각 구성요소는 그 구성요소의 종류와 길이를 서술하는 4바이트 헤더로 시작한다.

### 서비스 그룹

WCCP를 지원하는 라우터와 캐시들의 집합으로 구성되어 있다. 이 라우터들은 웹 트래픽을 서비스 그룹의 캐시로 보낸다. 서비스 그룹의 설정은 어떻게 트래픽이 서비스 그룹의 캐시들로 분산되는지 결정한다.

### GRE 패킷 캡슐화

라우터들은 HTTP 패킷을 특정 서버의 IP 주소와 함께 캡슐화함으로써 그 서버로 리다이렉트한다. 이 패킷 캡슐화는 `일반 라우터 캡슐화(Generic Router Encapsulation, GRE)`임을 나타내는 IP 헤더 `proto` 필드도 포함하고 있다.

proto 필드의 존재는 수신 측 프락시에게 그 패킷이 캡슐화된 패킷을 갖고 있음을 말해준다. 패킷이 캡슐화되어 있기 때문에, 클라이언트 IP 주소를 잃어버리지 않는다.

### WCCP 부하 균형

WCCP 라우터와 그들의 수신 서버들은 그들이 살아 있고 동작 중임을 다른 장비들이 알 수 있도록 `하트비트 메시지`를 서로 교환한다. 만약 특정 수신 서버가 하트비트 메시지를 보내지 않게 되었다면, WCCP 라우터는 트래픽 요청을 그 노드로 리다이렉트하는 대신 인터넷으로 바로 보낸다.





# 7. 인터넷 캐시 프로토콜(ICP)

캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있도록 해준다. 만약 캐시가 요청한 콘텐츠를 갖고 있지 않다면 근처의 형제 캐시 중 콘텐츠를 갖고 있는 캐시에서 콘텐츠를 가져온다. 이 때, 원 서버에 질의하는 것보다 비용이 더 들지 않을 것을 기대한다.

이런 점에서 ICP는 일종의 `캐시 클러스터링 프로토콜`이라고 할 수 있으며, 한 차례 이상의 ICP 질의를 통해 HTTP 요청 메시지의 최종 목적지를 결정 할 수 있다는 점에서 `리다이렉션 프로토콜`이라고 볼 수 있다.

ICP는 `객체 발견 프로토콜`이다. 캐시는 이 프로토콜을 사용해 근처의 캐시 모두에게 특정 URL을 갖고 있는지 한 번에 물어본다. 근처의 캐시들은 그 URL을 갖고 있으면 `HIT`, 없으면 `MISS`라고 답한다.

ICP는 단순하고 가볍다. ICP 메시지는 파싱하기 쉽도록 네트워크 바이트 순서에 따라 32비트 크기로 맞추어진 구조체다. 이 메시지들은 효율을 위해 `UDP 다이어그램`을 통해 전송된다. UDP는 `신뢰할 수 없는 인터넷 프로토콜`이며, 전송 중에 데이터가 파괴될 수 있다. 따라서 데이터그램의 손실을 감지할 수 있도록 타임아웃이 설정되어 있을 필요가 있다.

## OP 코드

OP 코드는 `ICP 메시지의 의미`를 서술하는 8비트 값이다. 기본 OP 코드는 ICP_OP_QUERY 요청 메시지이고 ICP_OP_HIT와 ICP_OP_MISS 응답 메시지이다.



## 버전

이 8비트 버전 번호는 `ICP 프로토콜의 버전 번호`를 서술한다.



## 메시지 길이

`ICP 메시지의 총 길이`를 바이트 단위로 나타낸 것. 이 값을 저장할 공간이 16비트이기 때문에 ICP 메시지 크기는 16,383바이트를 넘길 수 없다.



## 요청 번호

ICP를 지원하는 캐시는 동시에 여러 요청과 응답을 추적하기 위해 요청 번호를 사용한다. 응답 메시지는 요청 메시지와 언제나 같은 요청 번호를 담고 있어야 한다.



## 옵션

32비트 ICP 옵션 필드는 ICP의 동작을 변경하는 플래그를 담고 있는 비트 벡터이다. ICPv2는 두 개의 플래그를 정의하는데, 둘 다 ICP_OP_QUERY 요청을 수정한다.

ICP_FLAG_HIT_OBJ 플래그는 문서 데이터가 ICP 응답으로 돌아오는 것을 가능하게 할 것인지의 여부를 결정한다.

ICP_FLAG_SRC_RTT 플래그는 형제 캐시가 측정한 원 서버로의 왕복 시간에 대한 추정을 요청한다.



## 옵션 데이터

32비트 옵션 데이터는 옵션 기능을 위해 예약되어 있다. ICPv2는 옵션 데이터의 하위 16비트를 형제로부터 원 서버까지의 왕복 시간 측정값을 담아놓는데 사용한다. 이 측정값은 선택적이다.



## 발송자 호스트 주소

메시지 발송자의 32비트 IP 주소를 담고 있는 필드. 역사적인 이유로 존재하며 실제로는 사용되지 않는다.



## 페이로드

페이로드의 콘텐츠는 메시지의 형태에 따라 달라진다.

ICP_OP_QUERY라면, 원래 요청자의 호스트 주소와 NUL로 끝나는 URL이 순서대로 들어있다.
ICP_OP_HIT_OBJ라면, NUL로 끝나는 URL, 16비트의 객체 크기, 객체 데이터가 순서대로 들어있다.





# 8. 캐시 배열 라우팅 프로토콜

대량의 트래픽은 프락시 서버에게도 부담이다. 이러한 부하를 분산하기 위해 여러 대의 프락시 서버를 두고 하나의 프락시 서버처럼 보이게 할 수 있다. 이를 `캐시 배열 라우팅 프로토콜(CARP)`이라고 한다.

##### ICP vs CARP

ICP에서는 모든 캐시가 독립적인 하나의 캐시로서 존재한다. 즉, 서로 중복되는 문서를 캐시하고 있을 수 있다는 것이다. 그래서 어떤 캐시가 어떤 문서를 가지고 있는지 모든 캐시에게 요청해보지 않는 이상 알 수가 없다.

반면, CARP는 웹 객체의 URL에 `해시 함수`를 적용함으로써 하나의 웹 객체를 반드시 하나의 프락시 서버에 속하도록 만든다. 따라서 한 번의 검색으로 그 객체의 위치를 결정할 수 있다. 이는 보통 캐싱 프락시에서 이루어지지만 브라우저에서 해시 함수를 계산하는 플러그인을 설정할 수도 있다.

##### CARP의 단점

하지만 CARP가 좋은 것만은 아니다. 프락시 서버 중 하나가 사용할 수 없게 되면, 해시 함수를 다시 정의해야 한다. 이는 이미 다른 프락시 서버에 배치되어 있는 콘텐츠의 재배치가 필수적으로 동반된다.

또한 CARP는 비교적 새로운 프로토콜이기 때문에 ICP만을 수행하는 기존 프락시 서버는 쉽게 이 배열에 속할 수 없다.

##### CARP 리다이렉션

- 참여하는 프락시 서버의 테이블을 최신으로 유지한다. 프락시 서버들은 각각이 살아 있는지 알아보기 위해 주기적으로 폴링된다.
- 각 참여 프락시 서버들에 대해 해시 함수를 계산한다. 해시 함수가 반환하는 값은 이 프락시가 처리할 수 있는 부하의 양을 계산에 넣는다.
- 요청된 웹 객체의 URL에 근거한 숫자값을 반환하는 분리된 해시 함수를 정의한다.
- URL의 해시 함수와 프락시 서버의 해시 함수의 합계로 값의 배열을 얻는다. 이 값들에 대한 최댓값이 그 URL을 위해 사용할 프락시 서버를 결정한다. 계산값의 유일성이 보장되기 때문에, 같은 웹 객체에 대한 뒤이은 요청은 같은 프락시 서버로 포워딩될 것이다.





# 9. 하이퍼텍스트 캐싱 프로토콜

ICP는 리소스의 존재 여부를 결정할 때 URL만을 보낸다. 하지만 추가적인 정보에 대한 헤더가 없기 때문에 응답이 정확하지 않을 수 있다. `하이퍼텍스트 캐싱 프로토콜(Hyper Text Caching Protocol, HTCP)`은 이를 보완한다.

HTCP는 URL과 모든 요청 및 응답 헤더를 활용하여 응답의 정확성을 높인다. 또한, 형제 캐시들이 서로의 캐시 안에 있는 선택된 문서의 추가 및 삭제를 모니터링, 요청하고 캐싱 정책을 변경할 수 있게 해준다.

## 헤더

헤더 영역은 32비트 메시지 길이, 8비트 주 프로토콜 버전, 8비트 부 프로토콜 버전으로 이루어져 있다. 메시지 길이는 모든 헤더, 데이터, 인증 크기를 포함한다.



## 데이터

데이터 영역은 HTCP 메시지를 포함하며 데이터 길이, OP 코드, 응답 코드 등을 포함한다.

추가적으로 인증, 캐싱 정책 설정 등의 작업도 수행 가능하다.

